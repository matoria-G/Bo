<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>XDoclet: Attribute-Oriented Programming - Using Value Objects</title><style type="text/css" media="all">
          @import url("./style/maven-base.css");
          
			    @import url("./style/maven-theme.css");</style><link rel="stylesheet" href="./style/print.css" type="text/css" media="print"></link><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"></meta><meta name="author" content="Marcus Brito"></meta><meta name="email" content="pazu@users.sourceforge.net"></meta><link rel="shortcut icon" href="favicon.ico"></link><link rel="icon" href="favicon.ico"></link></head><body class="composite"><div id="banner"><a href="http://xdoclet.sourceforge.net/" id="organizationLogo"><img alt="XDoclet Team" src="./images/logo.gif"></img></a><a href="http://xdoclet.sourceforge.net/xdoclet/" id="projectLogo"><img alt="XDoclet" src="http://sflogo.sourceforge.net/sflogo.php?group_id=31602&amp;type=5"></img></a><div class="clear"><hr></hr></div></div><div id="breadcrumbs"><div class="xleft">
                	Last published: 16 April 2005
                  | Doc for 1.2.3</div><div class="xright">
        
        <a href="http://xdoclet.sourceforge.net/xdoclet/" class="externalLink" title="External Link">Home</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="http://sourceforge.net/projects/xdoclet/" class="externalLink" title="External Link">SourceForge Project</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="http://xdoclet.sourceforge.net/wiki/" class="externalLink" title="External Link">Wiki</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/xdoclet/" class="externalLink" title="External Link">Browse CVS</a>
      
        
          
            <span class="separator">|</span>
          
        
        <a href="http://opensource.atlassian.com/projects/xdoclet/secure/CreateIssue!default.jspa" class="externalLink" title="External Link">Create an Issue</a>
      </div><div class="clear"><hr></hr></div></div><div id="leftColumn"><div id="navcolumn"><div id="menuXDoclet"><h5>XDoclet</h5><ul><li class="none"><a href="index.html">Overview</a></li><li class="none"><a href="status.html">News and Status</a></li><li class="none"><a href="install.html">Download/Installation</a></li><li class="none"><a href="using.html">Using XDoclet</a></li><li class="none"><a href="bp.html">Best Practices</a></li><li class="none"><a href="faq.html">FAQ</a></li><li class="none"><a href="licenses/xdoclet-license.html">License</a></li></ul></div><div id="menuAnt_Task_Reference"><h5>Ant Task Reference</h5><ul><li class="none"><a href="ant/xdoclet/DocletTask.html">&lt;doclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/ejb/EjbDocletTask.html">&lt;ejbdoclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/hibernate/HibernateDocletTask.html">&lt;hibernatedoclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/jdo/JdoDocletTask.html">&lt;jdodoclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/jmx/JMXDocletTask.html">&lt;jmxdoclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/mockobjects/MockObjectDocletTask.html">&lt;mockdoclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/portlet/PortletDocletTask.html">&lt;portletdoclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/spring/SpringDocletTask.html">&lt;springdoclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/apache/tapestry/TapestryDocletTask.html">&lt;tapestrydoclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/web/WebDocletTask.html">&lt;webdoclet .. /&gt;</a></li><li class="none"><a href="ant/xdoclet/modules/wsee/WseeDocletTask.html">&lt;wseedoclet .. /&gt;</a></li></ul></div><div id="menuTag_Reference"><h5>Tag Reference</h5><ul><li class="none"><a href="tags/apache-tags.html">apache (@soap @struts @axis @tapestry)</a></li><li class="none"><a href="tags/bea-tags.html">bea (@weblogic)</a></li><li class="none"><a href="tags/borland-tags.html">borland (@bes)</a></li><li class="none"><a href="tags/caucho-tags.html">caucho (@resin)</a></li><li class="none"><a href="tags/ejb-tags.html">ejb (@ejb @dao)</a></li><li class="none"><a href="tags/exolab-tags.html">exolab (@castor)</a></li><li class="none"><a href="tags/hp-tags.html">hp (@hpas)</a></li><li class="none"><a href="tags/hibernate-tags.html">hibernate (@hibernate)</a></li><li class="none"><a href="tags/ibm-tags.html">ibm (@websphere)</a></li><li class="none"><a href="tags/java-tags.html">java (@javabean)</a></li><li class="none"><a href="tags/jboss-tags.html">jboss (@jboss)</a></li><li class="none"><a href="tags/jdo-tags.html">jdo (@jdo)</a></li><li class="none"><a href="tags/jmx-tags.html">jmx (@jmx)</a></li><li class="none"><a href="tags/jsf-tags.html">jsf (@jsf)</a></li><li class="none"><a href="tags/macromedia-tags.html">macromedia (@jrun)</a></li><li class="none"><a href="tags/mockobjects-tags.html">mockobjects (@mock)</a></li><li class="none"><a href="tags/mvcsoft-tags.html">mvcsoft (@mvcsoft)</a></li><li class="none"><a href="tags/mx4j-tags.html">mx4j (@mx4j)</a></li><li class="none"><a href="tags/objectweb-tags.html">objectweb (@jonas)</a></li><li class="none"><a href="tags/oracle-tags.html">oracle (@oc4j)</a></li><li class="none"><a href="tags/orion-tags.html">orion (@orion)</a></li><li class="none"><a href="tags/portlet-tags.html">portlet (@portlet)</a></li><li class="none"><a href="tags/pramati-tags.html">pramati (@pramati)</a></li><li class="none"><a href="tags/spring-tags.html">spring (@spring)</a></li><li class="none"><a href="tags/sun-tags.html">sun (@sunone)</a></li><li class="none"><a href="tags/sybase-tags.html">sybase (@easerver)</a></li><li class="none"><a href="tags/tjdo-tags.html">tjdo (@tjdo)</a></li><li class="none"><a href="tags/web-tags.html">web (@web @jsp)</a></li><li class="none"><a href="tags/webwork-tags.html">webwork (@webwork)</a></li><li class="none"><a href="tags/wsee-tags.html">wsee (@wsee)</a></li><li class="none"><a href="tags/xdoclet-tags.html">xdoclet (@xdoclet @doc @msg)</a></li></ul></div><div id="menuFeature_Documentation"><h5>Feature Documentation</h5><ul><li class="none"><strong><a href="valueobjects.html">Using Value Objects</a></strong></li><li class="none"><a href="envhandling.html">EJB Environment Handling</a></li></ul></div><div id="menuAdvanced"><h5>Advanced</h5><ul><li class="none"><a href="maven-plugin.html">Maven Plug-in</a></li><li class="none"><a href="merge.html">Merge Points</a></li><li class="none"><a href="ide/index.html">IDE Integration</a></li><li class="none"><a href="migration.html">Migration from EJBDoclet</a></li><li class="none"><a href="ant15.html">Ant 1.5 Troubleshooting</a></li></ul></div><div id="menuCommunity"><h5>Community</h5><ul><li class="none"><a href="feedback.html">Feedback</a></li><li class="none"><a href="resources.html">Resources</a></li><li class="none"><a href="tools.html">Tools</a></li></ul></div><div id="menuDevelopment"><h5>Development</h5><ul><li class="none"><a href="development/index.html">Developer Guide</a></li><li class="none"><a href="api/index.html">Javadoc (API)</a></li><li class="none"><a href="templates/index.html">Template Language (*.xdt)</a></li><li class="none"><a href="http://xdoclet.sourceforge.net/xjavadoc/" class="externalLink" title="External Link">XJavaDoc Site</a></li></ul></div><div id="search"><h5>Search XDoclet</h5><form action="http://www.google.com/search" method="get"><a href="http://www.google.com" class="navlink"><img height="32" width="75" alt="Google" src="http://www.google.com/logos/Logo_25wht.gif"></img></a><input name="q" maxlength="255" size="15" type="text" value="" id="q"></input><input name="btnG" type="submit" value="Go" id="btnG"></input><input name="domains" type="hidden" value="http://xdoclet.sourceforge.net/xdoclet"></input><input name="sitesearch" type="hidden" value="http://xdoclet.sourceforge.net/xdoclet" id="search"></input></form></div><div id="menuProject_Documentation"><h5>Project Documentation</h5><ul><li class="none"><a href="index.html">About XDoclet</a></li><li class="collapsed"><a href="project-info.html">Project Info</a></li><li class="collapsed"><a href="maven-reports.html">Project Reports</a></li><li class="none"><a href="http://maven.apache.org/development-process.html" class="externalLink" title="External Link">Development Process</a></li></ul></div><a href="http://maven.apache.org/" title="Built by Maven" id="poweredBy"><img alt="Built by Maven" src="./images/logos/maven-button-1.png"></img></a></div></div><div id="bodyColumn"><div class="contentBox"><div class="section"><a name="Using_Value_Objects"></a><h2>Using Value Objects</h2><p>
                The &lt;valueobject&gt; task is the XDoclet embodiment of the Value
                Object pattern, as described in <em>Core J2EE Patterns</em>.
                This pattern is also published in many other books and community sites
                around the world, and has proven to be an essential pattern to solve
                some EJB shortcomings.
            </p><p>
                Motivation: every remote enterprise bean call may go through the network,
                implying a heavy performance penalty. For entity beans this is specially
                dangerous: every entity bean has a getter and a setter for its
                properties, and each of these calls would incur a remote, networked
                call. If your application is filling a form using the bean properties it
                would make a remote call for each property. No, no good.
            </p><p>
                The solution is to create a coarse-grained object that contains some
                or all the bean properties and provide a method to create this object
                from the bean properties and another method to set the bean properties
                from such an object. This object is what we call the Value Object, a
                POJO (plain old java object) containing the enterprise bean property
                values. The following diagram illustrates this approach.
            </p><p>
                <img src="images/vo1.png" alt=""></img>
            </p><div class="subsection"><a name="Multiple_Value_Objects_Strategy"></a><h3>Multiple Value Objects Strategy</h3><p>
                    Suppose you have defined a <code>Customer</code> entity with properties
                    such as id, name, birth date, full address, number of children, preferred
                    TV series, whether s/he likes fruit loops or cheerios and oodles of
                    other information. You need them in different parts of your application.
                    However, sometimes you just need the customer ID and name. It would be a
                    waste of bandwidth and CPU to create a value object with all properties
                    and pass it to your application, specially if you got thousands or
                    millions of them.
                </p><p>
                    In a scenario like the one above, it would be useful to define
                    multiple value objects, each one containing a different set of
                    properties. You could have a <code>CustomerFull</code> VO containing all
                    properties and a <code>CustomerLight</code> VO containing just the
                    customer ID and name.
                </p><p>
                    Your entity bean would provide methods to obtain both value objects,
                    and perhaps methods to update the entity from both of them. The following
                    diagram illustrates this approach.
                </p><p>{{{INSERT UML DIAGRAM HERE}}}</p></div></div><div class="section"><a name="Using_Value_Objects_in_XDoclet"></a><h2>Using Value Objects in XDoclet</h2><p>
                XDoclet helps you to define and create your value objects. Below you
                can see a XDoclet-tagged Entity Bean source code, with @tags related to
                Value Object generation. Let's take a look at a bean marked up to
                generate Value Objects. <b>Please note that this is not a complete
                example:</b> there are many tags missing, only the ones related to Value
                Objects are presented here.
            </p>
    <div class="source"><pre>
package example.ejb;

import javax.ejb.EntityBean;
import java.util.Collection;
import java.util.Date;

/**
 * This is a Value Object usage example for XDoclet. It demonstrates the use
 * of most value object features like property selection, aggregation and
 * composition.
 *
 * @ejb.bean
 *   type="CMP"
 *   name="Customer"
 *   view-type="local"
 *
 * @ejb.value-object
 *   name="Customer"
 *   match="*"
 *
 * @ejb.value-object
 *   name="CustomerLight"
 *   match="light"
 */
public abstract class CustomerEJB implements EntityBean {

    /**
     * @ejb.value-object match="light"
     * @ejb.persistence
     */
    public abstract String getId();
    public abstract void setId(String id);

    /**
     * @ejb.value-object match="light"
     * @ejb.persistence
     */
    public abstract String getName();
    public abstract void setName(String name);

    /**
     * @ejb.value-object
     *   aggregate="example.vo.ProductValue"
     *   aggregate-name="PreferredProducts"
     *   members="example.interfaces.Product"
     *   members-name="PreferredProduct"
     *   relation="external"
     * @ejb.relation
     *   name="Customer-Product"
     *   role-name="customer-prefers-products"
     */
    public abstract Collection getPreferredProducts();
    public abstract void setPreferredProducts(Collection products);

    /**
     * @ejb.value-object
     *   compose="example.vo.AddressValue"
     *   compose-name="Addresses"
     *   members="example.interfaces.Address"
     *   members-name="Address"
     *   relation="external"
     * @ejb.relation
     *   name="Customer-Address"
     *   role-name="customer-has-addresses"
     */
    public abstract Collection getAddresses();
    public abstract void setAddresses();

    /**
     * @ejb.persistence
     */
    public abstract int getNumberOfChildren();
    public abstract void setNumberOfChildren(int nof);

    /**
     * @ejb.persistence
     */
    public abstract boolean getLikesFruitLoops();
    public abstract void setLikesFruitLoops(boolean loops);

    /**
     * @ejb.persistent-field
     */
    public abstract boolean getLikesCheerios();
    public abstract void setLikesCheerios(boolean cheerios);

    /**
     * @ejb.interface-method
     */
    public abstract CustomerValue getCustomerValue();

    /**
     * @ejb.interface-method
     */
    public abstract CustomerLightValue getCustomerLightValue();

    /**
     * @ejb.interface-method
     */
    public abstract void setCustomerValue(CustomerValue value);
}
</pre></div>
  <p>
                As you can see, there is only one tag you need to write to instruct
                XDoclet to generate value objects: <code>@ejb.value-object</code>.
                However, there are many places and uses for this tag. Let's go through
                the basic steps to mark your bean until you get everything generated by
                XDoclet.
            </p><div class="subsection"><a name="Value_Object_Declaration"></a><h3>Value Object Declaration</h3><p>
                    The first thing to do is to inform XDoclet which value objects it
                    will generate for your bean. At class level, introduce the
                    <code>@ejb.value-object</code> tag and supply at least the
                    <code>name</code> and <code>match</code> parameter. The name
                    parameter will tell XDoclet how to name the generated class for that
                    value object. XDoclet will apply the pattern task parameter to the
                    supplied name to determine the class name. The default pattern is
                    <code>{0}Value</code>, so in this example we get two classes
                    generated: <code>CustomerValue</code> and <code>CustomerLightValue</code>.
                </p><p>
                    The <code>match</code> parameter will tell XDoclet which entity
                    properties will be included in the generated value object. It's just
                    an identifier that you will have to repeat at each property getter
                    you want included in the value object. The <code>*</code> is a special
                    value, meaning that all properties will be included. So, in this
                    example the <code>CustomerValue</code> will have the same properties
                    as the entity bean and the <code>CustomerLightValue</code> will have
                    only the <code>id</code> and <code>name</code> properties.
                </p></div><div class="subsection"><a name="How_Relationships_Work"></a><h3>How Relationships Work</h3><p>
                    Starting with a given source entity and the target on the other side of a relation,
                    there are 1:1, 1:n, n:1, and n:n relations.
                </p><p>
                    Internally to XDoclet, a relation is tracked separately of either side of the
                    relation using the name attribute of @ejb.relation. If both sides of a
                    relation have an @ejb.relation tag with a matching name attribute (the "name"
                    attribute is the key that is used to uniquely identify the relationship),
                    information that would otherwise be incomplete can be inferred. But when the
                    target relation does not have corresponding reverse visibility of the source
                    in the relation and there is no @ejb.relation tag in the target with a
                    matching name attribute, there are *some* cases where additional information
                    needs to be provided to XDoclet in lieu of the missing information. The
                    @ejb.target-relation tag provides the ability to provide this information.
                    Thus, it is only needed or used when there is one-way visibility on a
                    relation and the information that would normally be provided at the target is
                    critical to the complete set of information that is necessary to generate the
                    information about the relation as a whole.
                </p><p>
                    The primary case of where this is necessary is where you have an 1:n
                    unidirectional link (there is no link visibility on the n side of the link).
                    Since 1:n links are modeled with the n side keeping a foreign key reference
                    of the 1 side, attempting to generate a 1:n link without reverse visibility
                    leaves XDoclet without the critical information it needs to know: the
                    related-pk-field attribute. Using the target-relation tag allows this
                    information to be provided. It's possible to model a 1:1 link this way,
                    where the schema visibility is target-to-source, but the desired design
                    visibility is source to target (for example, creating a new application on
                    top of a legacy schema.) In this case the target-relation tag is used to
                    describe the schema details, even though the generated APIs are reversed of
                    that and under normal 1:1 circumstances, it would be fine to store the
                    foreign key in the source entity.
                </p><p>
                    n:n and n:1 relations are the easy cases, because the source entity contains
                    the foreign key of the related entity. Whether or not there is reverse
                    visibility is irrelevant to XDoclet since it has all the information it needs
                    about the relation in the @ejb.relation tag.
                </p></div><div class="subsection"><a name="Aggregation_and_Composition"></a><h3>Aggregation and Composition</h3><p>
                    Value objects can have <code>compose</code> and <code>aggregate</code>
                    properties. These are multi valued properties that map an EJB relationship.
                    In this example we've got both aggregate and compose properties,
                    those being <code>preferredProducts</code> and <code>addresses</code>,
                    respectively.
                </p><p>
                    Aggregation should be used when the related object is not directly
                    dependent on the one we're declaring the value object.
                    <code>Product</code> has no direct dependency to <code>Customer</code>,
                    so the <code>preferredProducts</code> relationship is just an
                    aggregation. This means that the generated accessor methods for this
                    relationship will lookup <code>Product</code> entities when adding
                    them via the generated <code>addPreferredProduct()</code> method.
                </p><p>
                    Composition should be used when the related object is directly
                    dependent on the one we're declaring the value object, and cannot
                    exist without it. The creation of the related object is the
                    responsibility of the entity we're coding. <code>Address</code> is
                    dependent on <code>Customer</code>, so the addresses relationship is
                    a composition. This means that the generated accessor methods for
                    this relationship will create and remove <code>Address</code>
                    entities when adding and removing them via the generated
                    <code>addAddress()</code> and <code>removeAddress()</code> methods.
                </p><p>
                    Aggregation and composition may be confusing at first. As a rule of
                    thumb, consider object creation responsibility: if the entity we're
                    coding isn't responsible for creating the related entity, then it's
                    aggregation. If it is responsible for this, then it's composition. We
                    ask you to take a look at the generated code so you can really grasp the
                    difference between the two.
                </p><p>
                    Now let's break down the many parameters that are needed to
                    accomplish a multi valued property on a value object.  The 
                    <code>aggregate-name</code> (or <code>compose-name</code>)
                    parameter tells XDoclet how the accessor methods to this property in
                    the value object should be called. The value of this parameter should be
                    the method name, sans <code>get</code> or <code>set</code>. In this
                    example, we will have methods called <code>getPreferredProducts()</code>
                    and <code>setPreferredProducts()</code>, because PreferredProducts was
                    the aggregate-name for the relationship.
                </p><p>
                    The <code>aggregate</code> (or <code>compose</code>) parameter
                    tells XDoclet which should be the type of items contained in
                    the multi valued property. This should be a fully qualified class name.
                    In this example, the <code>getAddresses()</code> method of the value
                    object will return a <code>Collection</code> of
                    <code>example.vo.AddressValue</code> objects. Things should be
                    starting to make sense, no?
                </p><p>
                    The <code>members</code> parameter tells XDoclet the fully qualified
                    type of the related objects. This should be the type of the objects
                    returned by the entity getter. Please note that <code>aggregate</code>
                    and <code>aggregate-name</code> (or <code>compose</code> and
                    <code>compose-name</code>) relate to names and types in the value
                    object, while <code>members</code> and <code>members-name</code>
                    relate to names and types in the entity bean. In this example, the
                    <code>getPreferredProducts()</code> method returns a
                    <code>Collection</code> of <code>example.interfaces.Product</code>
                    objects, so this should be the value of the <code>members</code>
                    parameter.
                </p><p>
                    The <code>members-name</code> parameter should be the name of the
                    method in the related object that XDoclet should use to get the
                    object that will be put in the multi valued value object property,
                    without <code>get</code> or <code>set</code>. In this example,
                    XDoclet needs to call a <code>Product.getProductValue()</code> method
                    to obtain the <code>ProductValue</code>that will be put in the value
                    <code>preferredProducts</code> property. Are you still with me?
                </p><p>
                    Last, the <code>relation</code> parameter, which only accepts the
                    <code>external</code> value tells XDoclet that this property can be
                    updated outside of the scope of this value object, so the generated
                    method should always retrieve the property value. For relations,
                    this is a no brainer: always include the <code>relation="external"</code>
                    parameter.
                </p></div><div class="subsection"><a name="Exposing_Generated_Methods"></a><h3>Exposing Generated Methods</h3><p>
                    Please notice the last three methods in this example. The Bean
                    implementation class generated by XDoclet will contain them, but by
                    default they won't be included in the remote or local interface for the
                    bean. If you need to change that, you should declare them as abstract
                    in your beans and tag them as you wish. In this example, we want the
                    <code>getCustomerValue()</code>, <code>getCustomerLightValue()</code>
                    and <code>setCustomerValue(CustomerValue)</code>
                    methods exposed in the remote interface, so we tag them with
                    @ejb.interface-method. We don't want the
                    <code>setCustomerLightValue()</code> method exposed, so we don't
                    declare it here -- it will be in the generated implementation,
                    however.
                </p></div></div><div class="section"><a name="Customizing_the_valueobject_task"></a><h2>Customizing the valueobject task</h2><p>
                The <code>&lt;valueobject&gt;</code> task can be customized to
                your liking, to change things like the name of the package where the
                generated classes go and the name of the generated value objects.
            </p><p>
                You can change the target package using a nested
                <a href="ant/xdoclet/tagshandler/PackageTagsHandler.PackageSubstitution.html">
                <code>packageSubstitution</code>
                </a>
                element. For example, suppose we want all our value objects generated
                under the <code>example.valueobjects</code> package.
            </p>
    <div class="source"><pre>&lt;valueobject&gt;
    &lt;packageSubstitution packages="ejb" substituteWith="valueobjects"/&gt;
&lt;/valueobject&gt;</pre></div>
  <p>
                This tells XDoclet to substitute all packages names ending in "ejb" with
                a package name ending in "valueobjects". The
                <code>packageSubstitution</code> element is common to all
                XDoclet subtasks, so it's a good thing to understand how to use it.
            </p><p>
                Now, if you don't like the default naming pattern for value objects, you
                can change it by setting the <code>pattern</code> attribute for the
                <code>&amp;lt;valueobject&amp;gt;</code> task. The value must contain
                <code>{0}</code> in the name, which XDoclet will substitute with the
                bean name. In the above example, if we want our value objects to be
                named <code>CustomerVO</code> and <code>CustomerLightVO</code>, in the
                <code>examples.valueobjects</code> package, this would be the task
                declaration:
            </p>
    <div class="source"><pre>&lt;valueobject pattern="{0}VO"&gt;
    &lt;packageSubstitution packages="ejb" substituteWith="valueobjects"/&gt;
&lt;/valueobject&gt;</pre></div>
  <div class="subsection"><a name="Modifying_the_generated_value_object"></a><h3>Modifying the generated value object</h3><p>
                    XDoclet provides merge points in the value object template that you
                    can use to add custom code to the generated value objects. If you
                    don't know about merge points, you should <a href="merge.html">read
                    about them now</a>.
                </p><p>
                    The merge point is just before the closing brace of the generated
                    class and is called <code>valueobject-custom.xdt</code>. Please note
                    that the merge file can contain any java code and can use the
                    XDoclet template language. You can use this merge point to add
                    new methods or inner classes to the generated value object. If
                    you're <em>really</em> unhappy with the generated value object, you
                    can completely replace the template used by XDoclet to generate it.
                    Please refer to further documentation to learn about the template
                    language.
               </p></div></div><div class="section"><a name="Value_objects_and_self_reference"></a><h2>Value objects and self reference</h2><p>We want to answer the following question : "how do I represent a tree-like 
                structure with entity EJB and value-objects using XDoclet ?".
            </p><p>As you may know, entity EJB access through RMI can be costly and that's why one wants to
                use value-objects. However, we introduce a small catch here : we want the entity EJB to
                have some relationships with other entity EJB <em>of the same class</em>. This might seem
                easy but there's some catch when we want to create the value objects.
            </p><p>
                We choose to implement a family tree. 
                The family tree is made of <em>Persons</em>. Each person has a <em>name</em> and an <em>age</em>.
                Moreover, a <em>Person</em> knows its <em>children</em>.
                Each child is itself a <em>Person</em>. We just described a 1-N (1 person can have 0..N children)
                uni-directional relationship (we don't implement the fact that a child knows its father, nor brothers).
            </p><p>
                Coding this, we end up with :


    <div class="source"><pre>
    /** 
     * @ejb.interface-method
     * @ejb.relation name="offspring"
     *               role-name="father"
     *               target-ejb="Person"
     *               target-role-name="child"
     * 
     * @jboss.target-relation related-pk-field="name"
     *                        fk-column="father"
     * 
     * @ejb.value-object
     *     relation="external"
     *     aggregate="foundryserver.beans.interfaces.PersonLightValue"
     *     aggregate-name="Offspring"     
     *     members="foundryserver.beans.interfaces.PersonLocal"
     *     members-name="Offspring" 
     * 
     * @return Returns the offspring. 
     */
    public abstract Collection getOffspring();
        
    /* 
     * @ejb.interface-method 
     */
    public abstract PersonLightValue getPersonLightValue();
</pre></div>
  
            </p><p>
                To be able to run XDoclet on the EJB the first time, pay attention to the following points :
                <ul>
                    <li>Make sure you import the (fully qualified) <em>PersonLightValue</em> class in the code, although 
                        it doesn't exist yet (XDoclet will generate it itself). This also allows you tell XDoclet in which
                        package that class must be generated.
                    </li>

                    <li>Add an abstract getter to your entity to get the <em>PersonLightValue</em> object.
                        Read the "Exposing Generated Methods" part for more info. Keep in mind that the 
                        <em>PersonalValue</em> object will require <em>PersonalLightValue</em> to represent
                        the offspring. Because <em>PersonalValue</em> is generated by XDoclet, XDoclet
                        will need to have an access to <em>PersonalLightValue</em> and the only place where
                        you can allow this access is in the bean declaration itself.
                    </li>

                </ul>
            </p><p>Now a bit of explanation.
                The most important thing is to understand that a value-object cannot reference 
                other value-objects of the same class. Think about this situation : one wants to
                retrieve a person that has some children. He gets the value-object for that
                person. Now, if the value-object can references to the children, then those children's
                value-objects are added to the person's value-object. However, to be complete, those
                children's value objects must in turn have the value-objects of their children, etc.
                This is a recursive loop and doing so can lead us to have a graph of value-object covering the
                whole database. Not good. To prevent that, we <em>break</em> the loop. The strategy is
                to represent the children with a different class of value-object, the <em>PersonLightValue</em>.
                The particularity of this one is that it doesn't have any kind of reference to its own children,
                thus avoiding any uncontrollable recursive construction. Of course this is limiting a bit
                because we'll have to retrieve the children of Person manually.
            </p><p>To summarize, there will be two kind of value objects. The "main" one that has all
                information you need, including references to the offspring. The references will point
                to other value objects, the "light" one, representing the children, without any reference
                to their own children (break the loop).
            </p><p>An example of code to access the whole thing :
            
    <div class="source"><pre>
            PersonLocal stef = PersonUtil.getLocalHome().findByPrimaryKey("Stefan");
            PersonValue spv = stef.getPersonValue();
            out.println("&lt;br/&gt; "+spv.getName()+" is "+spv.getAge());
            
            PersonLightValue offspring[] = spv.getOffsprings();
            
            if( offspring != null)
                for( int i=0; i&lt;offspring.length; i++)
                    out.print( offspring[i].getName() + " - ");

            </pre></div>
  
            </p><p>To be complete, just have a look at the relationship declaration.
            It uses the "target-ejb" and "target-role" attributes. It's because we define a
            uni-directional relationship (see "How Relationships Work" for more information).
            For the same set of reasons, we also have to add the <code>@jboss.target-relation</code> tag.
            Finally, note that we used an aggregation. This is arbitrary.
            </p></div></div></div><div class="clear"><hr></hr></div><div id="footer"><div class="xright">© 2000-2005, XDoclet Team</div><div class="clear"><hr></hr></div></div></body></html>